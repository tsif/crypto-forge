<!DOCTYPE html>
<!-- saved from url=(0084)file:///Users/tsif/Downloads/key_wizard_standalone_html_jwk_%E2%87%84_pem.html#notes -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Key Wizard — JWK ⇄ PEM (RSA &amp; EC)</title>
  <style>
    :root { --bg:#f7f7fb; --card:#ffffff; --ink:#111; --muted:#6b7280; --line:#e5e7eb; --accent:#111; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; color:var(--ink); background:linear-gradient(#fafafa,#fff); }
    .container { max-width: 1100px; margin: 0 auto; padding: 24px; }
    h1 { font-size: clamp(22px, 3vw, 28px); margin: 0 0 4px; }
    h2 { font-size: 18px; margin: 0 0 8px; }
    p { margin: 0; }
    .sub { color: var(--muted); font-size: 14px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .card { background:var(--card); border:1px solid var(--line); border-radius: 14px; padding:16px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
    .grid { display:grid; gap:12px; }
    @media (min-width:900px){ .grid-2 { grid-template-columns: 1fr 1fr; } }
    label { font-weight: 600; font-size: 14px; }
    select, input[type="file"], textarea { border:1px solid var(--line); border-radius: 12px; padding:10px 12px; font: inherit; background:#fafafa; }
    textarea { width: 100%; min-height: 160px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; line-height: 1.45; }
    .btn { border:1px solid var(--line); border-radius: 999px; padding:10px 14px; background:#fff; cursor:pointer; }
    .btn:hover { background:#f6f6f6; }
    .btn.primary { background: var(--accent); color:#fff; border-color: var(--accent); }
    .btn.primary[disabled] { opacity: .6; }
    .stack { display:flex; flex-direction: column; gap:8px; }
    .space { height: 6px; }
    .titlebar { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:8px; }
    .muted { color: var(--muted); font-size: 12px; }
    .badge { padding: 6px 10px; background: #f3f4f6; border:1px solid var(--line); border-radius: 999px; font-size: 12px; }
    .footer { color:#6b7280; font-size: 12px; text-align:center; padding: 24px 0; }
    .controls-grid { display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    .field { display:flex; align-items:center; gap:8px; }
    .field > *:first-child { min-width: 80px; }
    .actions { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .outputs .card { display:flex; flex-direction: column; gap:8px; }
    .controls .card { display:flex; flex-direction: column; gap:12px; }
    .right { margin-left:auto; }
    .link { color: inherit; text-underline-offset: 2px; }
  </style>
</head>
<body>
  <div class="container">
    <header class="titlebar">
      <div>
        <h1>Key Wizard — JWK ⇄ PEM</h1>
        <p class="sub">Generate RSA or EC keypairs and convert between JWK/JWKS and PEM (SPKI / PKCS#8). Everything runs in your browser.</p>
      </div>
      <a class="muted link" href="file:///Users/tsif/Downloads/key_wizard_standalone_html_jwk_%E2%87%84_pem.html#notes">Security notes</a>
    </header>

    <section class="controls card">
      <div class="controls-grid">
        <div class="field">
          <label for="kind">Algorithm</label>
          <select id="kind">
            <option value="RSA">RSA</option>
            <option value="EC">EC (ECDSA)</option>
          </select>
        </div>

        <div class="field rsa-only" hidden="">
          <label for="rsaBits">Modulus</label>
          <select id="rsaBits">
            <option value="2048">2048</option>
            <option value="3072">3072</option>
            <option value="4096">4096</option>
          </select>
        </div>

        <div class="field rsa-only" hidden="">
          <label for="rsaHash">Hash</label>
          <select id="rsaHash">
            <option>SHA-256</option>
            <option>SHA-384</option>
            <option>SHA-512</option>
          </select>
        </div>

        <div class="field ec-only">
          <label for="ecCurve">Curve</label>
          <select id="ecCurve">
            <option>P-256</option>
            <option>P-384</option>
            <option>P-521</option>
          </select>
        </div>

        <div class="field">
          <label>alg</label>
          <div id="algBadge" class="badge">ES256</div>
        </div>
      </div>

      <div class="actions">
        <button id="generateBtn" class="btn primary">Generate keypair</button>
        <button id="clearBtn" class="btn">Clear</button>
        <span id="message" class="muted">Keys generated in your browser.</span>
      </div>
    </section>

    <section class="outputs grid grid-2">
      <div class="card">
        <div class="titlebar"><strong>Private JWK</strong><div class="actions"><button class="btn copy" data-target="privateJwk">Copy</button><button class="btn save" data-target="privateJwk" data-name="private.jwk.json">Save</button></div></div>
        <textarea id="privateJwk" readonly=""></textarea>
      </div>
      <div class="card">
        <div class="titlebar"><strong>Public JWK</strong><div class="actions"><button class="btn copy" data-target="publicJwk">Copy</button><button class="btn save" data-target="publicJwk" data-name="public.jwk.json">Save</button></div></div>
        <textarea id="publicJwk" readonly=""></textarea>
      </div>
      <div class="card">
        <div class="titlebar"><strong>JWK Set (Keypair)</strong><div class="actions"><button class="btn copy" data-target="jwksPair">Copy</button><button class="btn save" data-target="jwksPair" data-name="jwks-keypair.json">Save</button></div></div>
        <textarea id="jwksPair" readonly=""></textarea>
      </div>
      <div class="card">
        <div class="titlebar"><strong>JWK Set (Public only)</strong><div class="actions"><button class="btn copy" data-target="jwksPublic">Copy</button><button class="btn save" data-target="jwksPublic" data-name="jwks-public.json">Save</button></div></div>
        <textarea id="jwksPublic" readonly="" style="width: 496px; height: 119px;"></textarea>
      </div>
      <div class="card">
        <div class="titlebar"><strong>Public Key (SPKI PEM)</strong><div class="actions"><button class="btn copy" data-target="publicPem">Copy</button><button class="btn save" data-target="publicPem" data-name="public.pem">Save</button></div></div>
        <textarea id="publicPem" readonly=""></textarea>
      </div>
      <div class="card">
        <div class="titlebar"><strong>Private Key (PKCS#8 PEM)</strong><div class="actions"><button class="btn copy" data-target="privatePem">Copy</button><button class="btn save" data-target="privatePem" data-name="private.pem">Save</button></div></div>
        <textarea id="privatePem" readonly=""></textarea>
      </div>
    </section>

    <section class="card" style="margin-top:12px;">
      <h2>PEM → JWK / JWKS</h2>
      <p class="muted">Paste or upload a <strong>PUBLIC KEY</strong> (SPKI) or <strong>PRIVATE KEY</strong> (PKCS#8) PEM to convert. Works for RSA and EC keys. If the private key is provided, a corresponding public JWK and SPKI PEM will be derived.</p>
      <div class="actions" style="margin-top:8px;">
        <input id="pemFile" type="file" accept=".pem,.key,.txt">
        <button id="convertBtn" class="btn primary">Convert PEM</button>
        <button id="clearPemBtn" class="btn">Clear Input</button>
      </div>
      <div class="space"></div>
      <textarea id="pemInput" placeholder="-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----"></textarea>
    </section>

    <section id="notes" class="stack" style="margin-top:8px;">
      <h2>Notes &amp; safety</h2>
      <ul class="muted" style="padding-left:18px; margin:0;">
        <li>Keys are generated <em>locally</em> in your browser using the Web Crypto API. No data is sent anywhere by this page.</li>
        <li>Public PEMs are <code>SubjectPublicKeyInfo</code> (<code>BEGIN PUBLIC KEY</code>). Private PEMs are PKCS#8 (<code>BEGIN PRIVATE KEY</code>).</li>
        <li><strong>Never</strong> publish a JWKS that contains private keys. The “JWK Set (Keypair)” is for local testing only.</li>
        <li>Imported PEMs are auto-detected (RSA or EC). For RSA, RSASSA-PKCS1-v1_5, RSA-PSS, or RSA-OAEP are accepted. For EC, P‑256/P‑384/P‑521 are supported.</li>
        <li>The <code>alg</code> on imported keys is inferred (e.g., RS256 for RSA; ES256/384/512 for EC) and may not match the original usage.</li>
      </ul>
    </section>

    <div class="footer">© <span id="year">2025</span> • Built for developers. Use at your own risk.</div>
  </div>

<script>
// ===== Utilities =====
const textEncoder = new TextEncoder();
function bufToBase64(buf){ const bytes = new Uint8Array(buf); let bin=""; for(let i=0;i<bytes.byteLength;i++) bin += String.fromCharCode(bytes[i]); return btoa(bin); }
function base64ToBuf(b64){ const bin = atob(b64); const len = bin.length; const bytes = new Uint8Array(len); for (let i=0;i<len;i++) bytes[i] = bin.charCodeAt(i); return bytes.buffer; }
function base64UrlFromBuf(buf){ return bufToBase64(buf).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/g,""); }
function derToPem(der, label){ const b64 = bufToBase64(der); const wrapped = b64.replace(/(.{64})/g, "$1\n"); return `-----BEGIN ${label}-----\n${wrapped}\n-----END ${label}-----`; }
function pemToDer(pem){ const match = pem.replace(/\r/g,"").match(/-----BEGIN ([^-]+)-----([\s\S]*?)-----END \1-----/); if(!match) throw new Error("Invalid PEM. Expected BEGIN/END blocks."); const label = match[1].trim(); const b64 = match[2].replace(/\s+/g,""); return { der: base64ToBuf(b64), label }; }
function prettyJson(obj){ return JSON.stringify(obj, Object.keys(obj).sort(), 2); }
function download(filename, text){ const blob = new Blob([text], { type: "application/octet-stream" }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }

async function jwkThumbprint(jwk){ // RFC7638 minimal members, JSON no spaces
  let json="";
  if(jwk.kty === 'RSA') json = JSON.stringify({ e: jwk.e, kty: jwk.kty, n: jwk.n });
  else if(jwk.kty === 'EC') json = JSON.stringify({ crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y });
  else throw new Error('Unsupported kty for thumbprint');
  const digest = await crypto.subtle.digest('SHA-256', textEncoder.encode(json));
  return base64UrlFromBuf(digest);
}

const RSA_HASHES = ['SHA-256','SHA-384','SHA-512'];
const EC_CURVES = ['P-256','P-384','P-521'];
function algForSelection(kind, hashOrCurve){ if(kind==='RSA'){ return { 'SHA-256':'RS256','SHA-384':'RS384','SHA-512':'RS512' }[hashOrCurve] || 'RS256'; } if(kind==='EC'){ return { 'P-256':'ES256','P-384':'ES384','P-521':'ES512' }[hashOrCurve] || 'ES256'; } }

async function tryImportRSA(format, der, isPrivate){
  for(const name of ['RSASSA-PKCS1-v1_5','RSA-PSS','RSA-OAEP']){
    for(const hash of RSA_HASHES){
      try{
        const usages = name==='RSA-OAEP' ? (isPrivate?['decrypt']:['encrypt']) : (isPrivate?['sign']:['verify']);
        const key = await crypto.subtle.importKey(format, der, name==='RSA-OAEP'?{name, hash}:{name, hash}, true, usages);
        return { key, name, hash };
      }catch(e){}
    }
  }
  return null;
}

async function tryImportEC(format, der, isPrivate){
  for(const curve of EC_CURVES){
    try{
      const key = await crypto.subtle.importKey(format, der, { name:'ECDSA', namedCurve: curve }, true, isPrivate?['sign']:['verify']);
      return { key, curve };
    }catch(e){}
  }
  return null;
}

function derivePublicFromPrivateJwk(jwk){
  if(jwk.kty==='RSA'){ const {kty,n,e} = jwk; return {kty,n,e}; }
  if(jwk.kty==='EC'){ const {kty,crv,x,y} = jwk; return {kty,crv,x,y}; }
  throw new Error('Unsupported kty');
}

// ===== DOM bindings =====
const el = id => document.getElementById(id);
const yearEl = el('year'); yearEl.textContent = new Date().getFullYear();
const kindSel = el('kind');
const rsaBitsSel = el('rsaBits');
const rsaHashSel = el('rsaHash');
const ecCurveSel = el('ecCurve');
const algBadge = el('algBadge');
const msg = el('message');
const generateBtn = el('generateBtn');
const clearBtn = el('clearBtn');

const privateJwkTA = el('privateJwk');
const publicJwkTA = el('publicJwk');
const jwksPairTA = el('jwksPair');
const jwksPublicTA = el('jwksPublic');
const publicPemTA = el('publicPem');
const privatePemTA = el('privatePem');

const pemInputTA = el('pemInput');
const pemFile = el('pemFile');
const convertBtn = el('convertBtn');
const clearPemBtn = el('clearPemBtn');

function setBusy(b){ generateBtn.disabled = b; convertBtn.disabled = b; }
function show(kind){
  const rsaOnly = document.querySelectorAll('.rsa-only');
  const ecOnly = document.querySelectorAll('.ec-only');
  rsaOnly.forEach(n=> n.hidden = kind !== 'RSA');
  ecOnly.forEach(n=> n.hidden = kind !== 'EC');
  const alg = kind==='RSA' ? algForSelection('RSA', rsaHashSel.value) : algForSelection('EC', ecCurveSel.value);
  algBadge.textContent = alg;
}

kindSel.addEventListener('change', ()=> show(kindSel.value));
rsaHashSel.addEventListener('change', ()=> show(kindSel.value));
ecCurveSel.addEventListener('change', ()=> show(kindSel.value));
show(kindSel.value);

function clearOutputs(){
  privateJwkTA.value = '';
  publicJwkTA.value = '';
  jwksPairTA.value = '';
  jwksPublicTA.value = '';
  publicPemTA.value = '';
  privatePemTA.value = '';
  msg.textContent = '';
}

clearBtn.addEventListener('click', clearOutputs);

async function generate(){
  setBusy(true); msg.textContent='';
  try{
    const isRSA = kindSel.value === 'RSA';
    let keyPair;
    if(isRSA){
      keyPair = await crypto.subtle.generateKey({ name:'RSASSA-PKCS1-v1_5', modulusLength: parseInt(rsaBitsSel.value,10), publicExponent: new Uint8Array([0x01,0x00,0x01]), hash: rsaHashSel.value }, true, ['sign','verify']);
    } else {
      keyPair = await crypto.subtle.generateKey({ name:'ECDSA', namedCurve: ecCurveSel.value }, true, ['sign','verify']);
    }

    const jwkPriv = await crypto.subtle.exportKey('jwk', keyPair.privateKey);
    const jwkPub = await crypto.subtle.exportKey('jwk', keyPair.publicKey);

    const kid = await jwkThumbprint(jwkPub);
    const alg = isRSA ? algForSelection('RSA', rsaHashSel.value) : algForSelection('EC', ecCurveSel.value);

    Object.assign(jwkPriv, { kid, alg, key_ops:['sign'] });
    Object.assign(jwkPub, { kid, alg, key_ops:['verify'] });

    const spki = await crypto.subtle.exportKey('spki', keyPair.publicKey);
    const pkcs8 = await crypto.subtle.exportKey('pkcs8', keyPair.privateKey);

    publicPemTA.value = derToPem(spki, 'PUBLIC KEY');
    privatePemTA.value = derToPem(pkcs8, 'PRIVATE KEY');

    publicJwkTA.value = prettyJson(jwkPub);
    privateJwkTA.value = prettyJson(jwkPriv);
    jwksPairTA.value = JSON.stringify({ keys:[jwkPub, jwkPriv] }, null, 2);
    jwksPublicTA.value = JSON.stringify({ keys:[jwkPub] }, null, 2);

    msg.textContent = 'Keys generated in your browser.';
  }catch(e){
    console.error(e); msg.textContent = 'Error: ' + (e && e.message ? e.message : String(e));
  }finally{ setBusy(false); }
}

generateBtn.addEventListener('click', generate);

pemFile.addEventListener('change', async (e)=>{ const f = e.target.files && e.target.files[0]; if(!f) return; const t = await f.text(); pemInputTA.value = t; });
clearPemBtn.addEventListener('click', ()=> pemInputTA.value='');

async function convertPem(){
  setBusy(true); msg.textContent='';
  try{
    const { der, label } = pemToDer(pemInputTA.value);
    const format = /PUBLIC KEY/.test(label) ? 'spki' : /PRIVATE KEY/.test(label) ? 'pkcs8' : null;
    if(!format) throw new Error('PEM must be PUBLIC KEY or PRIVATE KEY.');
    const isPrivate = format === 'pkcs8';

    let imported = await tryImportRSA(format, der, isPrivate);
    let family = 'RSA';
    if(!imported){ imported = await tryImportEC(format, der, isPrivate); family = 'EC'; }
    if(!imported) throw new Error('Failed to import key. Unsupported algorithm or malformed PEM.');

    const jwk = await crypto.subtle.exportKey('jwk', imported.key);
    const jwkPriv = isPrivate ? jwk : null;
    const jwkPub = isPrivate ? derivePublicFromPrivateJwk(jwk) : jwk;

    const kid = await jwkThumbprint(jwkPub);
    const inferredAlg = family==='RSA' ? 'RS256' : (jwkPub.crv==='P-384'?'ES384': (jwkPub.crv==='P-521'?'ES512':'ES256'));

    if(jwkPriv){ jwkPriv.kid = kid; jwkPriv.alg = inferredAlg; jwkPriv.key_ops = (family==='RSA' && imported.name==='RSA-OAEP') ? ['decrypt'] : ['sign']; }
    jwkPub.kid = kid; jwkPub.alg = inferredAlg; jwkPub.key_ops = (family==='RSA' && imported.name==='RSA-OAEP') ? ['encrypt'] : ['verify'];

    // Export PEMs
    let pubPemOut = '';
    let privPemOut = '';
    if(isPrivate){
      privPemOut = derToPem(der, 'PRIVATE KEY');
      const pubKey = await crypto.subtle.importKey('jwk', jwkPub, family==='RSA'? { name: imported.name || 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' } : { name:'ECDSA', namedCurve: jwkPub.crv }, true, (family==='RSA' && imported.name==='RSA-OAEP')?['encrypt']:['verify']);
      const spki = await crypto.subtle.exportKey('spki', pubKey);
      pubPemOut = derToPem(spki, 'PUBLIC KEY');
    } else {
      pubPemOut = derToPem(der, 'PUBLIC KEY');
    }

    publicJwkTA.value = prettyJson(jwkPub);
    privateJwkTA.value = jwkPriv ? prettyJson(jwkPriv) : '';
    jwksPairTA.value = jwkPriv ? JSON.stringify({ keys:[jwkPub, jwkPriv] }, null, 2) : JSON.stringify({ keys:[jwkPub] }, null, 2);
    jwksPublicTA.value = JSON.stringify({ keys:[jwkPub] }, null, 2);
    publicPemTA.value = pubPemOut;
    privatePemTA.value = privPemOut;

    msg.textContent = 'PEM converted successfully.';
  }catch(e){ console.error(e); msg.textContent = 'Error: ' + (e && e.message ? e.message : String(e)); }
  finally{ setBusy(false); }
}

convertBtn.addEventListener('click', convertPem);

// Copy/Save buttons (event delegation)
document.addEventListener('click', async (e)=>{
  const copyBtn = e.target.closest('.copy');
  if(copyBtn){ const id = copyBtn.getAttribute('data-target'); const ta = el(id); try{ await navigator.clipboard.writeText(ta.value||''); msg.textContent = 'Copied to clipboard.'; }catch(err){ msg.textContent = 'Copy failed.'; } }
  const saveBtn = e.target.closest('.save');
  if(saveBtn){ const id = saveBtn.getAttribute('data-target'); const name = saveBtn.getAttribute('data-name'); const ta = el(id); download(name, ta.value||''); }
});
</script>


</body></html>